(* ---- Auxiliary functions. ---- *)
let (|>) x f = f x

let separate pred =
  let rec loop holds fails = function
  | [] -> (reverse holds, reverse fails)
  | x :: xs -> 
      if pred x then 
        loop (x :: holds) fails xs
      else
        loop holds (x :: fails) xs
  in loop [] []

(* -------------------------------------------------------------------------- *)
(* ---- Non-negative reals represented as logarithms. ---- *)
type rplus = Exp of float
let rplus_of_float x =  Exp (log x)
let rplus_of_int a =  rplus_of_float(float_of_int a)
let float_of_rplus (Exp x) = exp x

let ( +.. ) =
  let log_plus x y = ( x +. log1p (exp (y -. x))) in
  fun (Exp x) (Exp y) ->
  if (x < y)
  then Exp (log_plus y x)
  else Exp (log_plus x y)
  
let ( *.. ) (Exp x) (Exp y) = Exp (x +. y)
let ( /.. ) (Exp x) (Exp y) = Exp (x -. y)
let ( <=. ) (Exp x) (Exp y) = x <= y

(* -------------------------------------------------------------------------- *)

(* ---- Effects and types ---- *)
effect Sample : float
effect Score : rplus -> unit

type 'a list_dist = (rplus * 'a) list 
type 'a model = unit -> 'a (* unit -> 'a!{Sample, Score} *)

(* ---- Random sampler and weighted branches ---- *)
let score (log_likelihood : rplus) : unit = perform (Score log_likelihood)

let weighted_branches = handler
  | effect (Score w) k -> (fun w' -> continue k () (w' *.. w))
  | v -> (fun w -> (w,v))
  | finally prog -> prog (Exp 0.)

let random_sampler = handler
  | effect Sample k -> continue k (perform (RandomFloat 1.))
  | v -> v

let bernoulli_sample (p : float) : bool =  (p > perform Sample);;

(* ---- Rain model for testing. ---- *)

let rain_model : bool model = fun () ->
  let rain = bernoulli_sample 0.2 in
  let sprinkler = bernoulli_sample 0.1 in
  let likelihood_wet_lawn = 
    (match (rain, sprinkler) with
    | ( true , true ) -> 0.99
    | ( true , false) -> 0.70
    | ( false, true ) -> 0.90
    | ( false, false) -> 0.01
    ) |> rplus_of_float
  in
  score likelihood_wet_lawn;
  rain

let whatever_model : int model = fun () ->
  let p1 = bernoulli_sample 0.2 in
  let p2 = bernoulli_sample 0.1 in
  if p1 && p2 then
    (score (Exp 0.8);
    let p3 = bernoulli_sample 0.5 in
    if p3 then
      (score (Exp 0.2); 3)
    else
      (score (Exp 0.3); 2))
  else if p1 then
    (* This one should be droped by the SMC. *)
    (score (Exp -1000000.); score (Exp 1000000.); score (Exp 0.1); 1)
  else
    (score (Exp 0.4); 0)

(* ---- Testing ---- *)
;;(*
let (w, rain) =
  with random_sampler handle
  with weighted_branches handle
  rain_model ()
in
print_endline (
  "Single run test : weight, value =" ^ (to_string (float_of_rplus w, rain))
)
;;*)
(* -------------------------------------------------------------------------- *)

(* ---- Sequential Monte Carlo ---- *)

let populate (k : int) (model : 'a model) : 'a list_dist =
  let rec loop i acc =
    if i < k then
      let result = 
        with random_sampler handle
        with weighted_branches handle
          score (Exp 0. /.. rplus_of_int k);
          model ()
      in
      loop (i + 1) (result :: acc)
    else
      acc
  in 
  loop 0 []

let aggregate (pop : 'a list_dist) : 'a list_dist =
  let rec aggr_aux acc = function
    | [] -> acc
    | (w, x) :: xs ->
      let holds, fails = separate (fun (w, a) -> x = a) xs in
      let new_w = fold_left (fun s (w, _) -> s +.. w) w holds in 
      aggr_aux ((new_w, x) :: acc) fails
  in 
  aggr_aux [] pop

let sum_weights (list_dist : 'a list_dist) : rplus = 
  fold_left (fun acc (w, x) -> acc +.. w) (rplus_of_int 0) list_dist

let normalise (pop : 'a list_dist) : 'a list_dist =
  let total = sum_weights pop in
  print_endline ("total size is: " ^ to_string (float_of_rplus total));
  map (fun (r,x) -> (r /.. total), x) pop

(* -------------------------------------------------------------------------- *)
(* ---- Test ---- *)
;;
let rain_pop_test =
    populate 5000 whatever_model
in
let result = 
  rain_pop_test 
  |> aggregate 
  |> normalise 
  |> map (fun (w,x) -> (float_of_rplus w), x)
in print_endline ("Final population:" ^ (to_string result))
;;


(* -------------------------------------------------------------------------- *)
(* ---- Resampling ---- *)

let weighted_choice (list_dist : 'a list_dist) : 'a = 
  (*ASSUME pxs is NON-EMPTY *)
  let total_w = sum_weights list_dist in
  let total_fuel = (float_of_rplus total_w) *. (perform Sample) in
  let rec choose fuel ((w, x) :: wxs) =
    let fuel = fuel -. float_of_rplus w in
    if fuel <= 0. then x else choose fuel wxs
  in
  choose total_fuel list_dist

let resample (list_dist : 'a list_dist) : 'a list_dist =
  let n = length list_dist in
  let total_w = sum_weights list_dist in
  let resample_model : 'a model = fun () -> (
    score total_w;
    weighted_choice list_dist )
  in
  populate n resample_model 


(* -------------------------------------------------------------------------- *)
(* ---- Test ---- *)

let populate_and_resample pop_size k (model : 'a model) : 'a list_dist =
  let list_dist = populate pop_size model in
  let rec resampler i list_dist =
    if (i <= 0) then
      list_dist
    else  
      resampler (i - 1) (resample list_dist)
  in 
  resampler k list_dist

;;
let aggregated = aggregate (populate_and_resample 500 2 whatever_model) in
perform (Print (to_string aggregated ^ "\n"));
map (fun (Exp w,x) -> (exp w, x)) (normalise aggregated)
;;

(* -------------------------------------------------------------------------- *)
(* ---- SMC ---- *)

type 'a thunky = Done of 'a | Thunk of unit -> 'a thunky

let yield_on_score = handler
  | effect (Score w) k -> (score w; Thunk k)
  | v -> Done v

(* Dont like the handler positioning. *)
let smc pop_size k (model : 'a model) : 'a list_dist =
  let advance = function
    | w, Done v -> (w, Done v)
    | w, Thunk t -> with weighted_branches handle (score w; t ())
  in
  let rec finalize = function
    | w, Done v -> (w, v)
    | todo -> finalize (advance todo)
  in
  let thunk_model () = with yield_on_score handle model () in
  let list_dist = populate pop_size thunk_model in
  let rec resampler i list_dist =
    if (i <= 0) then
      map finalize list_dist
    else  
      list_dist |> resample |> map advance |> resampler (i-1)
  in
  with random_sampler handle
  resampler k list_dist

(* -------------------------------------------------------------------------- *)
(* ---- Test ---- *)

;;
let aggregated = aggregate (smc 500 2 whatever_model) in
perform (Print (to_string aggregated ^ "\n"));
map (fun (Exp w,x) -> (exp w, x)) (normalise aggregated)
;;